<footer class="site-footer">
    <p>
        {{ .Site.Title }} &copy; {{ now.Year }} &middot; Powered by chaos goblin
        energy
    </p>
</footer>

<script>
    (function () {
        // Find ALL content containers with grass borders
        const containers = document.querySelectorAll(
            ".posts-container, .post-container, .page-container, .archive-container, .note-scroll-single",
        );
        if (containers.length === 0) return;

        // Get current theme for sprite paths
        const currentTheme = localStorage.getItem('themeStyle') || 'fantasy';
        const spritePath = `/${currentTheme}/sprites/cat`;
        const sheetPath = `${spritePath}/sheets`;

        // All themes now use sprite sheets
        const usesSpriteSheets = true;

        // Sprite sheet config varies by theme (different sprite sheets have different frame counts)
        const themeSheetConfigs = {
            'fantasy': { walk: 8, run: 8, idle: 8 },
            'cabin': { walk: 8, run: 8, idle: 8 },
            'sci-fi': { walk: 6, run: 6, idle: 8 },
            'cyberpunk': { walk: 6, run: 6, idle: 8 },
            'underwater': { walk: 6, run: 8, idle: 8 }
        };
        const themeFrames = themeSheetConfigs[currentTheme] || themeSheetConfigs['fantasy'];
        const sheetConfig = {
            walk: { frames: themeFrames.walk, duration: 600 },
            run: { frames: themeFrames.run, duration: 400 },
            idle: { frames: themeFrames.idle, duration: 800 }
        };
        const frameWidth = 140;

        // Sprite sheet paths (all themes)
        const sprites = {
            walkNorth: `${sheetPath}/walk_north.png`,
            walkNortheast: `${sheetPath}/walk_north-east.png`,
            walkEast: `${sheetPath}/walk_east.png`,
            walkSoutheast: `${sheetPath}/walk_south-east.png`,
            walkSouth: `${sheetPath}/walk_south.png`,
            walkSouthwest: `${sheetPath}/walk_south-west.png`,
            walkWest: `${sheetPath}/walk_west.png`,
            walkNorthwest: `${sheetPath}/walk_north-west.png`,
            runNorth: `${sheetPath}/run_north.png`,
            runNortheast: `${sheetPath}/run_north-east.png`,
            runEast: `${sheetPath}/run_east.png`,
            runSoutheast: `${sheetPath}/run_south-east.png`,
            runSouth: `${sheetPath}/run_south.png`,
            runSouthwest: `${sheetPath}/run_south-west.png`,
            runWest: `${sheetPath}/run_west.png`,
            runNorthwest: `${sheetPath}/run_north-west.png`,
            idleNorth: `${sheetPath}/idle_north.png`,
            idleNortheast: `${sheetPath}/idle_north-east.png`,
            idleEast: `${sheetPath}/idle_east.png`,
            idleSoutheast: `${sheetPath}/idle_south-east.png`,
            idleSouth: `${sheetPath}/idle_south.png`,
            idleSouthwest: `${sheetPath}/idle_south-west.png`,
            idleWest: `${sheetPath}/idle_west.png`,
            idleNorthwest: `${sheetPath}/idle_north-west.png`,
        };

        // GIF fallbacks for themes missing some sprite sheets
        const gifFallbacks = {
            walkNorth: `${spritePath}/walk_north.gif`,
            walkNortheast: `${spritePath}/walk_north_east.gif`,
            walkEast: `${spritePath}/walk_east.gif`,
            walkSoutheast: `${spritePath}/walk_south_east.gif`,
            walkSouth: `${spritePath}/walk_south.gif`,
            walkSouthwest: `${spritePath}/walk_south_west.gif`,
            walkWest: `${spritePath}/walk_west.gif`,
            walkNorthwest: `${spritePath}/walk_north_west.gif`,
            runNorth: `${spritePath}/run_north.gif`,
            runNortheast: `${spritePath}/run_north_east.gif`,
            runEast: `${spritePath}/run_east.gif`,
            runSoutheast: `${spritePath}/run_south_east.gif`,
            runSouth: `${spritePath}/run_south.gif`,
            runSouthwest: `${spritePath}/run_south_west.gif`,
            runWest: `${spritePath}/run_west.gif`,
            runNorthwest: `${spritePath}/run_north_west.gif`,
            idleNorth: `${spritePath}/idle_north.gif`,
            idleNortheast: `${spritePath}/idle_north_east.gif`,
            idleEast: `${spritePath}/idle_east.gif`,
            idleSoutheast: `${spritePath}/idle_south_east.gif`,
            idleSouth: `${spritePath}/idle_south.gif`,
            idleSouthwest: `${spritePath}/idle_south_west.gif`,
            idleWest: `${spritePath}/idle_west.gif`,
            idleNorthwest: `${spritePath}/idle_north_west.gif`,
        };

        // Track which sprite sheets loaded successfully
        const loadedSheets = new Set();
        const failedSheets = new Set();

        const idleSprites = [
            sprites.idleNorth,
            sprites.idleNortheast,
            sprites.idleEast,
            sprites.idleSoutheast,
            sprites.idleSouth,
            sprites.idleSouthwest,
            sprites.idleWest,
            sprites.idleNorthwest,
        ];

        // Turn sequences for animated direction changes (using walk sprites)
        const turnEastToWest = [
            sprites.walkEast,
            sprites.walkSoutheast,
            sprites.walkSouth,
            sprites.walkSouthwest,
            sprites.walkWest,
        ];
        const turnWestToEast = [
            sprites.walkWest,
            sprites.walkSouthwest,
            sprites.walkSouth,
            sprites.walkSoutheast,
            sprites.walkEast,
        ];

        // Preload all sprites and track which ones load successfully
        Object.entries(sprites).forEach(([key, src]) => {
            const img = new Image();
            img.onload = () => loadedSheets.add(src);
            img.onerror = () => {
                failedSheets.add(src);
                // Preload the GIF fallback
                const fallbackImg = new Image();
                fallbackImg.src = gifFallbacks[key];
            };
            img.src = src;
        });

        // Inject sprite sheet CSS animations if needed
        if (usesSpriteSheets) {
            const style = document.createElement('style');
            // Element is 192px, frames are 140px, so scale factor is 192/140 ≈ 1.371
            const scale = 192 / 140;
            const walkSheetWidth = Math.round(frameWidth * sheetConfig.walk.frames * scale);
            const runSheetWidth = Math.round(frameWidth * sheetConfig.run.frames * scale);
            const idleSheetWidth = Math.round(frameWidth * sheetConfig.idle.frames * scale);
            const scaledHeight = Math.round(140 * scale);

            style.textContent = `
                @keyframes sprite-walk { from { background-position-x: 0; } to { background-position-x: -${walkSheetWidth}px; } }
                @keyframes sprite-run { from { background-position-x: 0; } to { background-position-x: -${runSheetWidth}px; } }
                @keyframes sprite-idle { from { background-position-x: 0; } to { background-position-x: -${idleSheetWidth}px; } }
                .ramona.sprite-sheet { background-repeat: no-repeat; background-position: 0 0; image-rendering: pixelated; }
                .ramona.sprite-sheet.anim-walk { background-size: ${walkSheetWidth}px ${scaledHeight}px; animation: sprite-walk ${sheetConfig.walk.duration}ms steps(${sheetConfig.walk.frames}) infinite; }
                .ramona.sprite-sheet.anim-run { background-size: ${runSheetWidth}px ${scaledHeight}px; animation: sprite-run ${sheetConfig.run.duration}ms steps(${sheetConfig.run.frames}) infinite; }
                .ramona.sprite-sheet.anim-idle { background-size: ${idleSheetWidth}px ${scaledHeight}px; animation: sprite-idle ${sheetConfig.idle.duration}ms steps(${sheetConfig.idle.frames}) infinite; }
            `;
            document.head.appendChild(style);
        }

        // Create Ramona for the first container only (persists across pages)
        const container = containers[0];
        const ramona = document.createElement("div");
        ramona.className = usesSpriteSheets ? "ramona sprite-sheet" : "ramona";
        ramona.setAttribute("role", "img");
        ramona.setAttribute("aria-label", "Ramona the cat");
        ramona.style.position = "fixed";
        ramona.style.pointerEvents = "none";
        ramona.style.zIndex = "1000";
        document.body.appendChild(ramona);

        // Get container bounds
        function getContainerBounds() {
            const rect = container.getBoundingClientRect();
            return {
                left: rect.left,
                width: rect.width,
                top: rect.top,
            };
        }

        // State - use single global key for cross-page persistence
        let bounds = getContainerBounds();
        const stateKey = "ramona_state";
        const savedState = JSON.parse(
            localStorage.getItem(stateKey) || "null",
        );
        const spriteSize = 192;
        // Use saved position as percentage of width for cross-page compatibility
        let xPercent = savedState?.xPercent ?? Math.random();
        let x = xPercent * (bounds.width - spriteSize);
        let direction =
            savedState?.direction ?? (Math.random() > 0.5 ? 1 : -1);
        let state = "walking"; // Always start walking - don't restore idle/turning states
        let speed = 1.25;
        let currentAnimClass = '';

        // Clamp x to valid bounds
        x = Math.max(0, Math.min(x, bounds.width - spriteSize));

        // Save state periodically (as percentage for cross-page compatibility)
        function saveState() {
            const xPercent = x / Math.max(1, bounds.width - spriteSize);
            localStorage.setItem(
                stateKey,
                JSON.stringify({ xPercent, direction, state }),
            );
        }
        setInterval(saveState, 500); // Save more frequently

        setSprite(direction === 1 ? sprites.walkEast : sprites.walkWest, 'walk');

        function setSprite(src, animType) {
            // Check if this sprite sheet failed to load - use GIF fallback
            const useGifFallback = failedSheets.has(src);
            const spriteKey = Object.keys(sprites).find(k => sprites[k] === src);
            const actualSrc = useGifFallback && spriteKey ? gifFallbacks[spriteKey] : src;

            ramona.style.backgroundImage = `url('${actualSrc}')`;

            // Remove old animation class
            if (currentAnimClass) ramona.classList.remove(currentAnimClass);

            if (useGifFallback) {
                // GIF fallback - no CSS animation needed, reset background-size
                ramona.style.backgroundSize = 'contain';
                currentAnimClass = '';
            } else if (usesSpriteSheets && animType) {
                // Sprite sheet - use CSS stepping animation
                ramona.style.backgroundSize = ''; // Let CSS class handle it
                currentAnimClass = `anim-${animType}`;
                ramona.classList.add(currentAnimClass);
            }
        }

        // Create dirt puff behind Ramona when running
        function createDirt(footX, footY) {
            const dirt = document.createElement("div");
            dirt.className = "ramona-dirt";
            // Offset behind Ramona based on direction
            const offsetX = direction === 1 ? -10 : 10;
            dirt.style.left =
                footX + offsetX + (Math.random() - 0.5) * 10 + "px";
            dirt.style.top = footY + (Math.random() - 0.5) * 5 + "px";
            // Random size
            const size = 6 + Math.random() * 6;
            dirt.style.width = size + "px";
            dirt.style.height = size + "px";
            document.body.appendChild(dirt);
            setTimeout(() => dirt.remove(), 500);
        }

        // Create heart above Ramona when idle
        function createHeart() {
            const heart = document.createElement("div");
            heart.className = "ramona-heart";
            heart.textContent = "♥";
            const offsetX = (Math.random() - 0.5) * 30;
            heart.style.left =
                bounds.left + x + spriteSize / 2 + offsetX + "px";
            heart.style.top = bounds.top - 114 + 20 + "px";
            const size = 12 + Math.random() * 12;
            heart.style.fontSize = size + "px";
            document.body.appendChild(heart);
            setTimeout(() => heart.remove(), 1500);
        }

        function startWalking() {
            state = "walking";
            speed = 1.25;
            setSprite(
                direction === 1 ? sprites.walkEast : sprites.walkWest,
                'walk'
            );
        }

        function startRunning() {
            state = "running";
            speed = 3.5;
            setSprite(direction === 1 ? sprites.runEast : sprites.runWest, 'run');
            // Run for 1-3 seconds then go back to walking
            setTimeout(startWalking, 1000 + Math.random() * 2000);
        }

        function startIdling() {
            state = "idle";
            const randomIdle =
                idleSprites[Math.floor(Math.random() * idleSprites.length)];
            setSprite(randomIdle, 'idle');
            // Resume walking after 2-12 seconds
            const idleTime = 2000 + Math.random() * 10000;
            setTimeout(() => {
                if (state === "idle") startWalking();
            }, idleTime);
        }

        function startTurning(newDirection) {
            state = "turning";
            const sequence = newDirection === -1 ? turnEastToWest : turnWestToEast;
            let frameIndex = 0;
            const turnInterval = setInterval(() => {
                if (frameIndex < sequence.length) {
                    setSprite(sequence[frameIndex], 'walk');
                    frameIndex++;
                } else {
                    clearInterval(turnInterval);
                    direction = newDirection;
                    startWalking();
                }
            }, 80); // 80ms per frame for smooth turn
        }

        function animate() {
            bounds = getContainerBounds();

            if (state === "walking" || state === "running") {
                x += speed * direction;

                // Spawn dirt when running
                if (state === "running") {
                    const footX =
                        bounds.left +
                        x +
                        (direction === 1 ? 40 : spriteSize - 40);
                    const footY = bounds.top + 10;
                    createDirt(footX, footY);
                }

                // Check boundaries
                const maxX = bounds.width - spriteSize;
                if (x >= maxX) {
                    x = maxX;
                    startTurning(-1);
                } else if (x <= 0) {
                    x = 0;
                    startTurning(1);
                }

                // Random behaviors
                const rand = Math.random();
                if (rand < 0.01) {
                    startIdling();
                } else if (rand < 0.02 && state === "walking") {
                    startRunning();
                }
            }

            // Spawn hearts when idle
            if (state === "idle" && Math.random() < 0.02) {
                createHeart();
            }

            // Update position
            ramona.style.top = bounds.top - 114 + "px";
            ramona.style.left = bounds.left + x + "px";

            requestAnimationFrame(animate);
        }

        // Start animation
        animate();
    })();
</script>

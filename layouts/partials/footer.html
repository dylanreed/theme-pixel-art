<footer class="site-footer">
    <p>
        {{ .Site.Title }} &copy; {{ now.Year }} &middot; Powered by chaos goblin
        energy
    </p>
</footer>

<script>
    (function () {
        // Find ALL content containers with grass borders
        const containers = document.querySelectorAll(
            ".posts-container, .post-container, .page-container, .archive-container, .note-scroll-single",
        );
        if (containers.length === 0) return;

        // Get current theme for sprite paths
        const currentTheme = localStorage.getItem('themeStyle') || 'fantasy';
        const spritePath = `/${currentTheme}/sprites/cat`;

        // Cat sprite paths (theme-aware)
        const sprites = {
            // Walking - all 8 directions
            walkNorth: `${spritePath}/walk_north.gif`,
            walkNortheast: `${spritePath}/walk_northeast.gif`,
            walkEast: `${spritePath}/walk_east.gif`,
            walkSoutheast: `${spritePath}/walk_southeast.gif`,
            walkSouth: `${spritePath}/walk_south.gif`,
            walkSouthwest: `${spritePath}/walk_southwest.gif`,
            walkWest: `${spritePath}/walk_west.gif`,
            walkNorthwest: `${spritePath}/walk_northwest.gif`,
            // Running
            runEast: `${spritePath}/run_east.gif`,
            runWest: `${spritePath}/run_west.gif`,
            // Idle - all 8 directions
            idleNorth: `${spritePath}/idle_north.gif`,
            idleNortheast: `${spritePath}/idle_northeast.gif`,
            idleEast: `${spritePath}/idle_east.gif`,
            idleSoutheast: `${spritePath}/idle_southeast.gif`,
            idleSouth: `${spritePath}/idle_south.gif`,
            idleSouthwest: `${spritePath}/idle_southwest.gif`,
            idleWest: `${spritePath}/idle_west.gif`,
            idleNorthwest: `${spritePath}/idle_northwest.gif`,
        };

        const idleSprites = [
            sprites.idleNorth,
            sprites.idleNortheast,
            sprites.idleEast,
            sprites.idleSoutheast,
            sprites.idleSouth,
            sprites.idleSouthwest,
            sprites.idleWest,
            sprites.idleNorthwest,
        ];

        // Turn sequences for animated direction changes (using walk sprites)
        const turnEastToWest = [
            sprites.walkEast,
            sprites.walkSoutheast,
            sprites.walkSouth,
            sprites.walkSouthwest,
            sprites.walkWest,
        ];
        const turnWestToEast = [
            sprites.walkWest,
            sprites.walkSouthwest,
            sprites.walkSouth,
            sprites.walkSoutheast,
            sprites.walkEast,
        ];

        // Preload all sprites to prevent blinking during animation
        Object.values(sprites).forEach((src) => {
            const img = new Image();
            img.src = src;
        });

        // Create Ramona for the first container only (persists across pages)
        const container = containers[0];
        const ramona = document.createElement("div");
        ramona.className = "ramona";
        ramona.setAttribute("role", "img");
        ramona.setAttribute("aria-label", "Ramona the cat");
        ramona.style.position = "fixed";
        ramona.style.pointerEvents = "none";
        ramona.style.zIndex = "1000";
        document.body.appendChild(ramona);

        // Get container bounds
        function getContainerBounds() {
            const rect = container.getBoundingClientRect();
            return {
                left: rect.left,
                width: rect.width,
                top: rect.top,
            };
        }

        // State - use single global key for cross-page persistence
        let bounds = getContainerBounds();
        const stateKey = "ramona_state";
        const savedState = JSON.parse(
            localStorage.getItem(stateKey) || "null",
        );
        const spriteSize = 192;
        // Use saved position as percentage of width for cross-page compatibility
        let xPercent = savedState?.xPercent ?? Math.random();
        let x = xPercent * (bounds.width - spriteSize);
        let direction =
            savedState?.direction ?? (Math.random() > 0.5 ? 1 : -1);
        let state = "walking"; // Always start walking - don't restore idle/turning states
        let speed = 1.25;

        // Clamp x to valid bounds
        x = Math.max(0, Math.min(x, bounds.width - spriteSize));

        // Save state periodically (as percentage for cross-page compatibility)
        function saveState() {
            const xPercent = x / Math.max(1, bounds.width - spriteSize);
            localStorage.setItem(
                stateKey,
                JSON.stringify({ xPercent, direction, state }),
            );
        }
        setInterval(saveState, 500); // Save more frequently

        setSprite(direction === 1 ? sprites.walkEast : sprites.walkWest);

        function setSprite(src) {
            ramona.style.backgroundImage = `url('${src}')`;
        }

        // Create dirt puff behind Ramona when running
        function createDirt(footX, footY) {
            const dirt = document.createElement("div");
            dirt.className = "ramona-dirt";
            // Offset behind Ramona based on direction
            const offsetX = direction === 1 ? -10 : 10;
            dirt.style.left =
                footX + offsetX + (Math.random() - 0.5) * 10 + "px";
            dirt.style.top = footY + (Math.random() - 0.5) * 5 + "px";
            // Random size
            const size = 6 + Math.random() * 6;
            dirt.style.width = size + "px";
            dirt.style.height = size + "px";
            document.body.appendChild(dirt);
            setTimeout(() => dirt.remove(), 500);
        }

        // Create heart above Ramona when idle
        function createHeart() {
            const heart = document.createElement("div");
            heart.className = "ramona-heart";
            heart.textContent = "â™¥";
            const offsetX = (Math.random() - 0.5) * 30;
            heart.style.left =
                bounds.left + x + spriteSize / 2 + offsetX + "px";
            heart.style.top = bounds.top - 114 + 20 + "px";
            const size = 12 + Math.random() * 12;
            heart.style.fontSize = size + "px";
            document.body.appendChild(heart);
            setTimeout(() => heart.remove(), 1500);
        }

        function startWalking() {
            state = "walking";
            speed = 1.25;
            setSprite(
                direction === 1 ? sprites.walkEast : sprites.walkWest,
            );
        }

        function startRunning() {
            state = "running";
            speed = 3.5;
            setSprite(direction === 1 ? sprites.runEast : sprites.runWest);
            // Run for 1-3 seconds then go back to walking
            setTimeout(startWalking, 1000 + Math.random() * 2000);
        }

        function startIdling() {
            state = "idle";
            const randomIdle =
                idleSprites[Math.floor(Math.random() * idleSprites.length)];
            setSprite(randomIdle);
            // Resume walking after 2-12 seconds
            const idleTime = 2000 + Math.random() * 10000;
            setTimeout(() => {
                if (state === "idle") startWalking();
            }, idleTime);
        }

        function startTurning(newDirection) {
            state = "turning";
            const sequence = newDirection === -1 ? turnEastToWest : turnWestToEast;
            let frameIndex = 0;
            const turnInterval = setInterval(() => {
                if (frameIndex < sequence.length) {
                    setSprite(sequence[frameIndex]);
                    frameIndex++;
                } else {
                    clearInterval(turnInterval);
                    direction = newDirection;
                    startWalking();
                }
            }, 80); // 80ms per frame for smooth turn
        }

        function animate() {
            bounds = getContainerBounds();

            if (state === "walking" || state === "running") {
                x += speed * direction;

                // Spawn dirt when running
                if (state === "running") {
                    const footX =
                        bounds.left +
                        x +
                        (direction === 1 ? 40 : spriteSize - 40);
                    const footY = bounds.top + 10;
                    createDirt(footX, footY);
                }

                // Check boundaries
                const maxX = bounds.width - spriteSize;
                if (x >= maxX) {
                    x = maxX;
                    startTurning(-1);
                } else if (x <= 0) {
                    x = 0;
                    startTurning(1);
                }

                // Random behaviors
                const rand = Math.random();
                if (rand < 0.01) {
                    startIdling();
                } else if (rand < 0.02 && state === "walking") {
                    startRunning();
                }
            }

            // Spawn hearts when idle
            if (state === "idle" && Math.random() < 0.02) {
                createHeart();
            }

            // Update position
            ramona.style.top = bounds.top - 114 + "px";
            ramona.style.left = bounds.left + x + "px";

            requestAnimationFrame(animate);
        }

        // Start animation
        animate();
    })();
</script>
